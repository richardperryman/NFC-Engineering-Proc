% Carleton University SCE 4th Year Project thesis style
% University of Ottawa MSc thesis style -- modifications to the report style
% modification of suthesis style of Stanford University
% Example of use:
\documentclass[12pt]{report}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{SCE4YPTemplate}
\usepackage{graphicx}
\usepackage{url}

    

\begin{document}
\title{SYSC4907 Project: \\ Sensor-Based Access Control System}
\author{
    Craig Shorrocks,
    Jessica Morris,
    Richard Perryman
}
	    % Remember to use your titles
	    % Use \copyrightyear{1885} to force a particular year
	    % for the copyright statement.
\copyrightfalse % do not produce a separate copyright page
		    % otherwise use \copyrighttrue
%    \figurespagefalse % do not produce a separate figures page
%    \tablespagefalse  % do not produce a separate tables page

% Here you insert the stuff that comes before the preface
% Each preface section is contained in a \prefacesection and starts on a
% new page.  These are numbered using Roman numerals.
% If there are no such pages, do not remove the \beforepreface command
% since it creates the title page.
\beforepreface

%=================================================================================

\prefacesection{Abstract}
	This report tells you all you need to know about something.

%=================================================================================

\prefacesection{Acknowledgements}
	I would like to thank my supervisor, anyone who paid me money, gave me
	equipment, etc.

%=================================================================================

% For some reason, these seem to require that you run latex twice?

\prefaceTOC   % to print the Table of Contents
\prefaceLOF   % to print the List of Figures
\prefaceLOT   % to print the List of Tables

%=================================================================================
		            
\prefacesection{List of Abbreviations}
    
\begin{tabular}[t]{l@{\hspace*{2cm}}l}
	AID & Application IDentifier \\
	APDU & Application Protocol Data Unit \\
	API & Application Programming Interface \\
	HMAC & Keyed-hash message authentication code \\
	MVC & Model-View-Controller \\
	NFC & Near Field Communication \\
\end{tabular}

%=================================================================================

\endpreface
	
%=================================================================================

\chapter{Introduction}

Give an introduction to your project.  This might include:
\begin{itemize}
  \item Motivation for your project
  \item Problem you are trying to solve
  \item Scope of your project
  \item Organization of your report
\end{itemize}
You should tune this appropriately for what best suits your project.


%=================================================================================

\chapter{The Engineering Project}

%=================================================================================

\section{Health and Safety}

Using the Health and Safety Guide posted on the course webpage, students will use this section to explain how they addressed the issues of safety and health in the system that they built for their project.

%=================================================================================

\section{Engineering Professionalism}

Using their course experience of ECOR 4995 Professional Practice, students should demonstrate how their professional responsibilities were met by the goals of their project and/or during the performance of their project. 

%=================================================================================

\section{Project Management}

One of the goals of the engineering project is real experience in working on a long-term team project.  Students should explain what project management techniques or processes were used to coordinate, manage and perform their project.

%=================================================================================

\section{Individual Contributions}

This section should carefully itemize the individual contributions of each team member. Project contributions should identify which components of work were done by each individual.  Report contributions should list the author of each major section of this report.

%---------------------------------------------------------------------------------

\subsection{Project Contributions}

Give the individual contributions of the each team member towards the project.

%---------------------------------------------------------------------------------

\subsection{Report Contributions}

Give the individual contributions of the each team member towards writing the
final report.

%=================================================================================

% Consider adding Node, Android? Maybe others?
\chapter{Technical Background}

%=================================================================================

\section{NFC}

%=================================================================================

\section{Cloud Computing}

%=================================================================================

%---------------------------------------------------------------------------------

\subsection{AWS}

%=================================================================================

\section{Security}

%=================================================================================

% Jess probably should rename these!
\section{Singe-board computers}

%=================================================================================

%---------------------------------------------------------------------------------

\subsection{Raspberry pi}

%---------------------------------------------------------------------------------

\subsection{Arduino} % ?

%=================================================================================

\chapter{Business Use Cases}

%=================================================================================

\section{Online Order Secure Pickup}

%=================================================================================

\section{Central Mail Package Pickup}

%=================================================================================

\section{Long Term Storage}

%=================================================================================

\section{Service Provider}

%=================================================================================

\chapter{Problem Analysis and System Design}

%=================================================================================

\section{Overall System Analysis}

The requirements of our system from the use cases described above lead us to a simple outline for the entire system.
The main component of the system would be the cloud server, which would store information regarding users, locks, and
the relationships between them. The lock hardware would need to be able to securely accept data from the user, and
securely send that data to the server for verification. Since handling electronic security can be difficult to do
manually, having an application that handles much of the busy work would greatly help users interact with the system.

% Not sure if this belongs here
One of the main goals of the system was to improve the reusability of the electronic keys that are created. For this
reason, the idea of a key was split into two parts: an authenticator, and an identity. Users would be able to create
many authenticators, which were things like a password, or a PIN. These then could be combined into an identity, which
would be used to open a particular lock. This allowed making identies that reuse the same authenticator, and reusing
identities for different locks.

Another goal of the system was to provide additional behaviour on top of just being able to unlock particular locks.
This extra behaviour was captured in the notion of a registration, which ties one lock to one identity. Through the
registration, we were able to implement notifications to the user as well as streaming of the lock's contents.

% Add picture of database stuff?

%=================================================================================

\section{NFC}

Determining how NFC communication should take place required analysis of two hardware systems: NFC card readers, as well
as mobile devices. The most desirable protocol would be able to handle the widest variety of available hardwares for
the two devices. The performance considerations between modes was fairly minimal, so preference was placed on the
portability of the solution.

%---------------------------------------------------------------------------------

\subsection{Card Readers}

% Todo: sources
Since NFC cards are primarily designed for NFC communications, there were few restrictions that stemmed from potential
choices in card reader. Since NFC communications are specified by the ISO, most cards support enough protocols that any
decision on our part would be very likely to be supported by any card that would be desirable for any other reason.

%---------------------------------------------------------------------------------

\subsection{Mobile Devices}

The two most popular operating systems for mobile devices are iOS and Android []. Since iOS devices have NFC disabled
for everything except Apple Pay[], the only option that remained was Android. Apple devices would represent a large
part of the potential market, so alternatives to NFC would have to be considered.

Among Android devices, there exist devices which have hardware support for NFC communications, and those which rely on
host-based card emulation. Devices with hardware support have a component called a Secure Element which performs all of
the communication with the external NFC terminal. Later, applications can query this element to determine the status of
the transaction, as well as other data. Devices which use host-based card emulation use a software implementation of
secure elements. Since host-based card emulation is done through software, it will run on all Android devices running
version 4.4 or greater[], which represents over 99\% of all devices currently in use.

% Find out which protocol we actually use!
Android offers an API called Beam which is the only way Anndroid devices can use NFC in active mode []. Beam,
however, does not support sending more than one message between devices. Since the information we are sending can be
fairly large in the interest of security, this was not feasible given the restrictions of the NFC protocols we used.
Further, active communications are easier to eavesdrop on, as discussed in the background section. We decided that these
costs outweighed the simplicity of the Beam API, so passive communications were chosen for the implementation.

% Discuss AID here? or in implementation? Here for now I guess
Since more than one application could potentially want to handle an NFC message, the message protocol contains a field
called the Application IDentifier, or AID []. These AIDs are just large numbers which identify which application should
handle the associated message. The Android operating system is responsible for delivering the APDUs to the
appropriate application's service []. Reserving a particular AID costs money, so we decided that the probability of a
collision ocurring when taking a public AID would be an acceptable cost for the purpose of our demonstrative
implementation.

%---------------------------------------------------------------------------------

\subsection{Protocol}

Since our NFC communications may require more data than can be fit within an Application Protocol Data Units (APDUs), we
required a protocol which would handle segmenting and recombining the message. APDUs are defined in ISO 7816-4 [] and are
the units used by ISO 14443-4 [], which describes the transmission protocol used by NFC devices. They are restricted to
256 bytes, including headers.

% Todo, some fact checking
To work around this, the hardware device connected to the shield maintains a buffer. Under ISO 14443-4, messages can be
reliably transferred, so managing this buffer is the main consideration of our protocol. The hardware determines the
maximum amount of data that can be stored in one APDU, and fills in this value into the length field of the APDU that it
sends to the Android device. Then, the Android application responds with the minimum of that much data,  and all of the
remaining data that it has to send. Once the hardware receives an amonut of data less than the potential maximum, it
deactivates the connection. In the event that the data from the Android application fits exactly into the last message
that would be sent, the protocol still works, as the application will then respond with zero data bytes.

% Todo: MSC / FSMs?

%=================================================================================

\section{Android}

The Android application's goal was to provide the end users with an easy way of interacting with the SBACS system.
Therefore the application was designed to be as simple as possible while still maintaining flexibility when dealing with
the cloud server as well as the many potential hardware devices.

%---------------------------------------------------------------------------------

\subsection{User Interface}

The natural decision for designing the basic workings of the application was to use the Model-View-Controller (MVC) 
design pattern. This pattern separates the underlying data (model) from the display that the user sees (view) as well as
the components that the user interacts with (controller). Android provides APIs to support MVC. Model objects can be
simple objects, but view objects can subclass the View class or its more specific subclasses, and the controller
objects can subclass the Adapter class or its subclasses.

Android applications themselves should follow the patterns set out by the standards. Activity classes represent the
pages that contain the various views and controllers that users can interact with. We decided on a design where the user
first encouters a login Activity, which prompts them to either sign up or log in. Once the user has logged in, we
provide a hub Activity which leads to the various other Activities in the application. These other Activities show the
various data related to the user, such as their authenticators and identities.

Communication between Activities is handled by a class provided by Android called an Intent. Intent objects contain
information about the nature of the request to begin the new Activity. In this way, information such as the user's
identification number could be sent from the login Activity to the hub Activity, which would allow the application to
correctly load the information from that user when displaying the data Activities.

%---------------------------------------------------------------------------------

\subsection{Notifications}

The design for the notifications that would inform end users of information such as their newly available registration
with a particular lock was based partly on decreasing load on the server. Having the server maintain a large amount of
session information as well as spending time and memory on the timers to be able to update the user of these changes
was thought to be too great a cost. For this reason, it seemed simpler and more effective to have the application poll
the server at a particular access point for new information.

This polling was implemented simply in the application using a service which runs in the background of the Android
device. This service regularly hits the server at a particular endpoint designed for handling these notifications. Since
many users may be using the application at once, it was important to consider the performance of the endpoint's code.
The endpoint returns information valuable to the application for display in the notification. The notifications make use
of Android notification's ability to launch an Acticity with an Intent to take the user to the appropriate Activity
associated with the notification.

%---------------------------------------------------------------------------------

\subsection{NFC Handler}

% Provide ref to section?
As mentioned earlier, the NFC communication method that we decided on used host-based card emulation. Android provides
and API to accomplish these communications, through the HostApduService class []. This class provides a framework for
creating a service which runs in the background on the Android device. The service handles setting up and closing NFC
communications, while also providing overrideable methods to determine what data should be sent based on the incoming
message.

Services also take an Intent object to determine their purpose. This feature was used to have the login Activity start
the service with the correct key information for a user's NFC authenticator. This way, the data sent could be overridden
with the user's secret key value. Since passive NFC communications are difficult to eavesdrop on, this was thought to be
a safe method of conveying the secret key to the lock without requiring too much data to be sent over the slow NFC
physical links. This passing of information of course was also configured to follow the protocol designed above for NFC
communications.

%=================================================================================

\section{Hardware}

%=================================================================================

\section{Cloud}

%=================================================================================

% For the physical thing - not sure if this should be here since Michel et al did basically all of this ;)
\section{Lock Demonstration}

%=================================================================================

\chapter{System Implementation}

%=================================================================================

\section{NFC}

%=================================================================================

\section{Android}

%=================================================================================

\section{Hardware}

%=================================================================================

\section{Cloud}

%=================================================================================

\chapter{Testing and Bug Fixes}

% Not really sure what to go with here

%=================================================================================

\chapter{Conclusions}

%=================================================================================

\renewcommand{\bibname}{References}
\begin{thebibliography}{AAA}
\bibitem{ABC} T. Me and R. You, "A great result," {\em Wonderful Journal}, vol. 5, no. 9,
	      pp. 1--11, 1998.
\bibitem{XYZ} J. Him and K. Her, "An even better result that you won't believe," {\em Best Journal Ever}, vol. 4, no. 8, pp. 55--66, 2002.
\end{thebibliography}
% If you have your general bibliography in a separate file mybib
% and you wish to use the plain style (see BIBTeX)
%    \bibliographystyle{cacm}
%    \bibliography{mybib}
    \addcontentsline{toc}{chapter}{\bibname}
    

%=================================================================================

\appendix

%=================================================================================

\chapter{Extra Simulation Results}

%=================================================================================

\chapter{Review of Linear Algebra}

%=================================================================================

\end{document}
